# 7/4
## ch2. 알고리즘 설계와 분석의 기초
### 알고리즘의 분석
점근적 분석 : 입력크기가 충분히 큰 경우에 대한 분석
#### 점근적 표기법 
O( g(n) ) : 기껏해야 g(n)의 비율로 증가하는 함수

Ω( g(n) ) : 적어도 g(n)의 비율로 증가하는 함수

Θ( g(n) ) : g(n)의 비율로 증가하는 함수

#### 시간복잡도 분석의 종류
Worst-case//Average-case//Best-case

## ch3. 점화식과 점근적 복잡도 분석
점화식 : 어떤 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것
### 점화식의 점근적 분석 방법
반복 대치 : 더 작은 문제에 대한 함수로 반복해서 대치해 나가는 해법

추정후 증명 : 결론을 추정하고 수학적 귀납법으로 이용하여 증명하는 방법

마스터 정리 : 형식에 맞는 점화식의 복잡도를 바로 알 수 있다.

## ch4. 정렬
### 기초적인 정렬 알고리즘
평균적으로 Θ(n2)의 시간이 소요되는 정렬 알고리즘들
#### 선택정렬
selectionSort(A[], n) { 

????????for last ← n downto 2 {  
????????????????A[1 ... last] 중 가장 큰 수 A[k]를 찾는다.  
????????????????A[k] ↔ A[last]; ?▷ A[k]와 A[last]의 값을 교환          
??????  } 
        
} 
#### 버블정렬
bubbleSort(A[], n)?{

????????for last ← n downto 2 {????????????                                 
????????????????for i ← 1 to last-1???????                                  
????????????????????????if (A[i] > A[i+1]) then A[i] ↔ A[i+1]; ▷ 원소 교환
                        
} 
#### 삽입정렬
insertionSort(A[], n)?{

????????for i ← 2 to n????  
????????????????A[1 ... i]의 적당한 자리에 A[i]를 삽입한다;?}
                
} 
### 고급 정렬 알고리즘
평균적으로 Θ(n log n)의 시간이 소요되는 정렬 알고리즘들
#### 병합정렬
mergeSort(A[],p,r) {

if(p<r) {   
q=(p+r)/2;  
mergeSort(A,p,q);  
mergeSort(A,q+1,r);  
merge(A,p,q,r);  
}  
}

merge(A[],p,q,r) {  
정렬되어 있는 두 배열 A[p...q]와 A[q+1...r]을 합쳐  
정렬된 하나의 배열 A[p...q]를 만든다.  
}


